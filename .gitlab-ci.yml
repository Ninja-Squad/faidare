---
stages:
  - test
  - build
  - staging
  - production


image: urgi/docker-browsers:latest


# Disable the Gradle daemon for Continuous Integration servers as correctness
# is usually a priority over speed in CI environments. Using a fresh
# runtime for each build is more reliable since the runtime is completely
# isolated from any previous builds.
variables:
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"
  GRADLE_USER_HOME: $CI_PROJECT_DIR/.gradle
  APP_NAME: gpds
  JAR_PATH: "backend/build/libs/${APP_NAME}.jar"


# Gradle cache for all jobs
cache:
  key: "$CI_COMMIT_REF_NAME"
  paths:
    - ".gradle"
    - "frontend/.gradle/"
    - "frontend/node_modules/"


# TESTS


lint:
  stage: test
  script: "./gradlew lint"


test-frontend:
  stage: test
  script: "./gradlew :frontend:test --parallel"
  artifacts:
    reports:
      junit:
        - "./frontend/karma-junit-tests-report/TEST*.xml"


test-backend:
  stage: test
  script: "./gradlew :backend:test --parallel"
  services:
    # even if that would be ideal
    # we can't just launch the service with just elasticsearch:6.3.1
    # because we need to pass some variables, but they are passed to _all_ containers
    # so they fail the start of other docker images like urgi/docker-browsers
    # the only solution is to override the entrypoint of the service and pass the arguments manually
    - name: docker.elastic.co/elasticsearch/elasticsearch:6.5.4
      alias: elasticsearch
      # discovery.type=single-node
      # single-node is necessary to start in development mode
      # so there will be no bootstrap checks that would fail on CI
      # especially the error regarding
      # `max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]`
      command: ["bin/elasticsearch", "-Ediscovery.type=single-node"]
  artifacts:
    reports:
      junit:
        - "./backend/build/test-results/test/TEST-*.xml"


# BUILD


build:
  stage: build
  script:
    - ./gradlew assemble
  artifacts:
    paths:
      - "$JAR_PATH"
    expire_in: 1 week
  only:
    changes:
      - .gitlab-ci.yml
      - backend/src/**/*
      - frontend/**/*


# DEPLOY


.deploy-to-vm: &deploy_to_vm
  # Hidden job which serves as template for executed jobs below.
  # See https://docs.gitlab.com/ee/ci/yaml/#anchors
  retry: 2
  ## SSH initialization
  before_script:
    - eval $(ssh-agent -s)
    - ssh-add <(echo "${SSH_PRIVATE_KEY}")
    - ssh -o StrictHostKeyChecking=no root@${SERVER_IP} 'echo "Successfully connected on $(hostname)"'
  script:
    # Copy jar
    - scp ./$JAR_PATH root@${SERVER_IP}:/opt/bootapp/${APP_NAME}-${ENV}.jar
    # Restarting service with the updated jar and the according Spring profiles enabled
    - ssh root@${SERVER_IP} "systemctl restart bootapp@${APP_NAME}-${ENV}"
    - eval $(ssh-agent -k)
    - echo "Deploy done. Application should be available at http://${SERVER_IP}:${APP_PORT}/${CONTEXT_PATH}"


deploy-to-staging:
  stage: staging
  variables:
    ENV: staging
    APP_PORT: ${STAGING_GPDS_PORT}
    CONTEXT_PATH: ${STAGING_GPDS_CONTEXT_PATH}
  <<: *deploy_to_vm
  only:
    refs:
      - master
    changes:
      - .gitlab-ci.yml
      - backend/src/**/*
      - frontend/**/*


deploy-to-beta:
  stage: staging
  variables:
    ENV: beta
    APP_PORT: ${BETA_GPDS_PORT}
    CONTEXT_PATH: ${BETA_GPDS_CONTEXT_PATH}
  <<: *deploy_to_vm
  only:
    refs:
      - branches
    changes:
      - .gitlab-ci.yml
      - backend/src/**/*
      - frontend/**/*
  when: manual
  allow_failure: false


deploy-to-int:
  stage: production
  variables:
    ENV: int
    APP_PORT: ${INT_GPDS_PORT}
    CONTEXT_PATH: ${INT_GPDS_CONTEXT_PATH}
  <<: *deploy_to_vm
  only:
    refs:
      - master
    changes:
      - .gitlab-ci.yml
      - backend/src/**/*
      - frontend/**/*
  when: manual
  allow_failure: false


deploy-to-public-prod:
  stage: production
  variables:
    ENV: public-prod
    APP_PORT: ${PUBLIC_PROD_GPDS_PORT}
    CONTEXT_PATH: ${PUBLIC_PROD_GPDS_CONTEXT_PATH}
  <<: *deploy_to_vm
  only:
    refs:
      - master
    changes:
      - .gitlab-ci.yml
      - backend/src/**/*
      - frontend/**/*
  when: manual
  allow_failure: false


deploy-to-private-prod:
  stage: production
  variables:
    ENV: private-prod
    APP_PORT: ${PRIVATE_PROD_GPDS_PORT}
    CONTEXT_PATH: ${PRIVATE_PROD_GPDS_CONTEXT_PATH}
  <<: *deploy_to_vm
  only:
    refs:
      - master
    changes:
      - .gitlab-ci.yml
      - backend/src/**/*
      - frontend/**/*
  when: manual
  allow_failure: false
